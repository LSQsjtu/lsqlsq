#include<cstdio>

int n;

void fun(int a1,int b1,int a2,int b2)
{
    if(a1+a2>n||b1+b2>n)
    return;
    else {
        fun(a1,b1,(a1+a2),(b1+b2));
        printf("%d/%d\n",a1+a2,b1+b2);
        fun((a1+a2),(b1+b2),a2,b2);
    }
}

int main()
{
    scanf("%d",&n);
    printf("0/1\n");
    fun(0,1,1,1);
    printf("1/1\n");
    return 0;
}
/*
法里数列
1至8阶的法里数列如下：

F1 = {0⁄1, 1⁄1}
F2 = {0⁄1, 1⁄2, 1⁄1}
F3 = {0⁄1, 1⁄3, 1⁄2, 2⁄3, 1⁄1}
F4 = {0⁄1, 1⁄4, 1⁄3, 1⁄2, 2⁄3, 3⁄4, 1⁄1}
F5 = {0⁄1, 1⁄5, 1⁄4, 1⁄3, 2⁄5, 1⁄2, 3⁄5, 2⁄3, 3⁄4, 4⁄5, 1⁄1}
F6 = {0⁄1, 1⁄6, 1⁄5, 1⁄4, 1⁄3, 2⁄5, 1⁄2, 3⁄5, 2⁄3, 3⁄4, 4⁄5, 5⁄6, 1⁄1}
F7 = {0⁄1, 1⁄7, 1⁄6, 1⁄5, 1⁄4, 2⁄7, 1⁄3, 2⁄5, 3⁄7, 1⁄2, 4⁄7, 3⁄5, 2⁄3, 5⁄7, 3⁄4, 4⁄5, 5⁄6, 6⁄7, 1⁄1}
F8 = {0⁄1, 1⁄8, 1⁄7, 1⁄6, 1⁄5, 1⁄4, 2⁄7, 1⁄3, 3⁄8, 2⁄5, 3⁄7, 1⁄2, 4⁄7, 3⁄5, 5⁄8, 2⁄3, 5⁄7, 3⁄4, 4⁄5, 5⁄6, 6⁄7, 7⁄8, 1⁄1}
n阶的法里数列F_n包含了较低阶的法里数列的全部项，特别是它包含F_{{n-1}}的全部项，和与n互质的每个数的相应分数。对大于1的n，其法里数列的中间项必定是1⁄2。
法里数列的相邻分数项有下述性质：

若a⁄b和c⁄d是法里数列的邻项，而有a⁄b < c⁄d，则它们之差c⁄d − a⁄b是1⁄bd。由于

c⁄d-a⁄b= {bc-ad}/{bd}，
上文就等于是说

bc − ad = 1。
例如1⁄3和2⁄5在F_{5}}F_{5}中是邻项，它们之差为1⁄15。

这结果的逆命题也成立。若

bc − ad = 1，
其中a,b,c和d为正整数，及有a < b和c < d，则a⁄b和c⁄d在阶为\max(b,d)}\max(b,d)的法里数列中是邻项。

若p⁄q在某法里数列的邻项是a⁄b和c⁄d，及

a⁄b < p⁄q < c⁄d，
则p⁄q是a⁄b和c⁄d的中间分数。换句话说，


例如在1⁄3和2⁄5间出现的第一项是3⁄8，在F_{8}}F_{8}出现。

Stern-Brocot树是一个数据结构，显出如何从0 (= 0⁄1)和1 (= 1⁄1)开始，以取中间分数来构成法里数列。

法里数列中的邻项分数，它们的连分数表示形式也密切相关。每个分数都有两个连分数表示，一个的尾项为1，另一个则大于1。考虑p⁄q，它第一次于F_{q}}F_{q}出现。以连分数表示为

[0;a_{1},a_{2},...,a_{n-1},a_{n},1]}[0;a_{1},a_{2},...,a_{{n-1}},a_{n},1]，或
[0;a_{1},a_{2},...,a_{n-1},a_{n}+1]}[0;a_{1},a_{2},...,a_{{n-1}},a_{n}+1]，
则p⁄q在F_{q}}F_{q}中最接近的邻项（这是两邻项中分母较大的）表示为连分数是

[0;a_{1},a_{2},...,a_{n}]}[0;a_{1},a_{2},...,a_{n}]，
而另一邻项则会表示为

[0;a_{1},a_{2},...,a_{n-1}]}[0;a_{1},a_{2},...,a_{{n-1}}]。
例如3⁄8有两个连分数表示：[0;2,1,1,1]和[0;2,1,2]，而它在F_{8}}F_{8}中的邻项为2⁄5，可写成[0;2,1,1]；和1⁄3，可写成[0;2,1]。


*/